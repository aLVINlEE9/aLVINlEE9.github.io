---
layout: post
title: Process
comments: true
categories: [ComputerScience/Operation System]
tags: [process, operation, os, operating system, 운영체제]
date: 2021-10-25 13:05:00



---

<br/>

이번에는 프로세스에 대해서 공부할 것이다.

디스크에 있는 것은 프로그램, 메모리에 로드된 것은 프로세스라고 한다.

프로세스는 Stack, Heap, Data, Code로 나뉜다.

```
+---------------+ max
|     stack     | 
+-------+-------+
|       |       |
|       v       |
|               |
|       ^       |
|       |       |
+-------+-------+
|     heap      |
+---------------+
|     data      |
+---------------+
|     text      |
+---------------+ 0
```

# Process State

프로세스의 상태는 현재 활동에 따라 달라진다.

![그림1.jpg](https://github.com/aLVINlEE9/aLVINlEE9.github.io/blob/master/assets/img/CS-Operating%20System/%EA%B7%B8%EB%A6%BC1.jpg?raw=true)

- New : 프로세스가 처음 생성되었을 떄.
- Ready : 프로세스가 프로세서에 할당되기를 기다릴 때.
- Running :  프로세스가 할당되어 실행될 때
- Wating : 프로세스가 이벤트를 기다릴 때.
- Terminated : 프로세스가 실행을 마쳤을 때.

<br/>

<br/>

<br/>

<br/>

<br/>

# Process Control Block (PCB)

각각의 프로세스는 자신의 정보 묶음인 PCB를 가지고 있다.

PCB에는 프로세스 상태와 프로그램 카운터, 메모리 한계, 레지스터 정보 등이 담겨있다.

- Process state : 프로세스 상태
- Program counter : 해당 프로세스가 이어서 실행해야 할 명령의 주소를 가리키는 카운터
- CPU register : 프로세스가 인터럽트 이후 올바르게 작업을 이어가기 위해 참조하는 CPU 레지스터 값.
- CPU-scheduling information : 프로세스의 중요도, 스케줄링 큐 포인터 등 스케줄링 파라미터 정보.
- Memory-management information : base, limit 레지스터 값, 페이지 테이블 등 메모리 시스템 정보
- Accounting information : 사용된 CPU총량, 프로세스 개수, 시간제한 등.
- I/O status information : 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록

<br/>

<br/>

<br/>

<br/>

<br/>

# Threads

프로세스를 쪼개 하나의 프로세스 안에서 동시에 여러 작업을 처리 할 수 있다.

지금까지는 싱글 스레드 프로세스를 전제하고 살펴봤다.

싱글 스레드 프로세스는 한번에 하나의 작업만 할 수 있다.

가령 워드 프로세서 프로그램을 실행한다면, 글자를 타이핑할 떄 같은 프로세스 안에서 동작하는 문법 교정기가 동시에 동작할 수 없다.

다음 포스트(멀티 쓰레드)에서 자세하게 다룬다.

<br/>

<br/>

<br/>

<br/>

<br/>

# Process Scheduling

멀티프로그래밍의 목적은 CPU를 최대로 사용하기 위해 항상 일부 프로세스를 실행하는 것이다.

타임쉐어링의 목적은 프로세스 간에 CPU를 자주 전환함으로써 사용자가 각 프로그램이 실행되는 동안 서로 상호작용할 수 있도록 만드는 것이다.

이러한 목적을 달성하기 위해 프로세스 스케줄러는 CPU에서의 프로그램의 실행을을 위해 사용가능한 프로세스를 선택하며, 어떤 프로세스를 프로세서에 할당할 것인가 결정하는 일을 프로세스 스케줄링이라고 한다.

<br/>

<br/>

## Scheduling Queues

 프로세스가 시스템에 들어오면 잡 큐(Job queue)에 들어간다.

잡 큐는 시스템의 모든 프로세스로 구성되어있다.

메인 메모리에서 실행을 기다리는 ready 상태의 프로세스들을 레디 큐(Ready queue)에 쌓인다.

입출력 장치를 기다리를 프로세스들은 디바이스 큐(Device queue)로 들어간다.

<br/>

<br/>

## Schedulers

레디 큐에 프로세스를 옮기는 것은 잡 스케줄러, 또는 Long-term 스케줄러라고 한다.

프로세스를 프로세서에 할당하는 것은 CPU 스케줄러, 또는 Short-term 스케줄러라고 한다.

 Long-term 스케줄러는 CPU 밖에서 가끔 수행된다.

Short-term 스케줄러는 그 반대다.



<br/>

<br/>

![What is Long-Term, Short-Term, and Medium-Term Scheduler?](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-is-longterm-shortterm-and-mediumterm-scheduler-longterm-shortterm-working.png)

<br/>

## Long-term 스케줄러(job 스케줄러)

내가 지금 수행해야할 job이 10개인데, 메모리에는 자리가 6자리가 없다고 한다.

그럼 당연히 10개중 6개를 골라야한다.

10개중 어떤 6개를 고를지 정하는것이 Long-term 스케줄러가 하는일이다.

job을 고르는거라 해서 Job 스케줄러 라고 하기도 한다.

저 위에 그림을 참고하면 Long-term 스케줄러는 pool로 부터 프로세스를 선별하고 실행을 위해 메모리에 적재 한다고 볼 수 있다.

또 Ready Queue에 적재하는 스케줄러가 Long-term 스케줄러가 된다.

CPU bound process 같은경우는 CPU가 쭉 작업을 해주는 즉 CPU가 계산해야하는 비중이 큰 프로세스를 말하고 I/O bound process 같은경우는 입출력을 많이 요구하는 프로세스이다.

만약 I/O bound process만 적재시키면, 입출력을 기다리느라 노는 CPU들이 많아질것이다

그렇다고 CPU bound process만 적재시키면, 입출력을 못받으니 사용자와 상호작용이 안될 것이다.

결국 제일 중요한건 적절한 비율의 혼합이다.

이것 또한 Long-term 스케줄러가 선택해서 적재하는 것이다.

<br/>

<br/>

## Short-term 스케줄러(CPU 스케줄러)

이어서 short-term 스케줄러를 설명하자면, 지금 메모리에 롱텀 스케줄러에 의해 6개의 job이 있다.

근데 실제 CPU 가 수행하는 것은 한개 뿐이다.

결국 이 6개중에 하나를 골라내는 것이 short-term스케줄러가 하는 일이다.

Short-term 스케줄러는 실행이 준비된 프로세스들 중 하나를 선별해 CPU에 할당해주는 것이다.

그럼 왜 단기(short-term)이라는 말이 붙었을까?

우리는 CPU를 놀지 않게 하는것이 제일 중요하다.

A 라는 프로세스를 수행하다가 사용자의 입력을 기다려야 하는 때가 오면 그걸 그대로 기다리면 CPU 낭비가 된다.

기다리는 동안 CPU에 수행되는 프로세스를 B로 교체 해서 수행 할 것이다.

그러다 또 I/O가 입력되면 그 프로세스를 다시 이어 수행하기 위해 CPU로 불러 온다.

이 외에도 time sharing을 통해 스케줄링 된다 하더라도 짧은 시간 이내에 교체가 될것이다.

즉 이 스케줄러는 최소 매 100 밀리세컨즈 단위로 수행이 되는데 따라서 짧은(단기) 스케줄러 라고 하는것이다.

반면에 long-term 스케줄러는 메모리에 올라간 프로세스가 끝날떄 새로 다시 채워 올려준다거나, 프로세스가 너무 많으면 때에 따라 올리지 않고 비워놓기때문에 term이 길 수 밖에 없다.

<br/>

<br/>

<br/>

<br/>

<br/>

# Context Switch

프로세스가 실행되다가 인터럽트가 발생해 운영체제가 개입하여 프로세서에 할당된 프로세스를 바꾸는 것을 말한다.

시스템 콜을 사용해야 하는 경우 프로세스가 자체적으로 처리할 수 없기 때문에 운영체제가 개입해야 한다.

프로세서가 다른 



------

*제가 올린 글에서 잘못된 부분이 있으면 제 메일로 연락주세요!*

*Reference :  **[https://parksb.github.io/article/7.html](https://parksb.github.io/article/7.html)**,  **[https://jhnyang.tistory.com/372](https://jhnyang.tistory.com/372)**, Operation System Concept*



<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">이승수</span>의 저작물인 이 저작물은(는) <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스</a>에 따라 이용할 수 있습니다.

