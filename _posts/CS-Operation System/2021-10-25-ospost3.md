---
layout: post
title: Process
comments: true
categories: [ComputerScience/Operation System]
tags: [process, operation, os, operating system, 운영체제]
date: 2021-10-25 13:05:00



---

<br/>

이번에는 프로세스에 대해서 공부할 것이다.

디스크에 있는 것은 프로그램, 메모리에 로드된 것은 프로세스라고 한다.

프로세스는 Stack, Heap, Data, Code로 나뉜다.

```
+---------------+ max
|     stack     | 
+-------+-------+
|       |       |
|       v       |
|               |
|       ^       |
|       |       |
+-------+-------+
|     heap      |
+---------------+
|     data      |
+---------------+
|     text      |
+---------------+ 0
```

# Process State

프로세스의 상태는 현재 활동에 따라 달라진다.

![그림1.jpg](https://github.com/aLVINlEE9/aLVINlEE9.github.io/blob/master/assets/img/CS-Operating%20System/%EA%B7%B8%EB%A6%BC1.jpg?raw=true)

- New : 프로세스가 처음 생성되었을 떄.
- Ready : 프로세스가 프로세서에 할당되기를 기다릴 때.
- Running :  프로세스가 할당되어 실행될 때
- Wating : 프로세스가 이벤트를 기다릴 때.
- Terminated : 프로세스가 실행을 마쳤을 때.

<br/>

<br/>

<br/>

<br/>

<br/>

# Process Control Block (PCB)

각각의 프로세스는 자신의 정보 묶음인 PCB를 가지고 있다.

PCB에는 프로세스 상태와 프로그램 카운터, 메모리 한계, 레지스터 정보 등이 담겨있다.

- Process state : 프로세스 상태
- Program counter : 해당 프로세스가 이어서 실행해야 할 명령의 주소를 가리키는 카운터
- CPU register : 프로세스가 인터럽트 이후 올바르게 작업을 이어가기 위해 참조하는 CPU 레지스터 값.
- CPU-scheduling information : 프로세스의 중요도, 스케줄링 큐 포인터 등 스케줄링 파라미터 정보.
- Memory-management information : base, limit 레지스터 값, 페이지 테이블 등 메모리 시스템 정보
- Accounting information : 사용된 CPU총량, 프로세스 개수, 시간제한 등.
- I/O status information : 프로세스에 할당된 입출력 장치 목록, 열린 파일 목록

<br/>

<br/>

<br/>

<br/>

<br/>

# Threads

프로세스를 쪼개 하나의 프로세스 안에서 동시에 여러 작업을 처리 할 수 있다.

지금까지는 싱글 스레드 프로세스를 전제하고 살펴봤다.

싱글 스레드 프로세스는 한번에 하나의 작업만 할 수 있다.

가령 워드 프로세서 프로그램을 실행한다면, 글자를 타이핑할 떄 같은 프로세스 안에서 동작하는 문법 교정기가 동시에 동작할 수 없다.

다음 포스트(멀티 쓰레드)에서 자세하게 다룬다.

<br/>

<br/>

<br/>

<br/>

<br/>

# Process Scheduling

멀티프로그래밍의 목적은 CPU를 최대로 사용하기 위해 항상 일부 프로세스를 실행하는 것이다.

타임쉐어링의 목적은 프로세스 간에 CPU를 자주 전환함으로써 사용자가 각 프로그램이 실행되는 동안 서로 상호작용할 수 있도록 만드는 것이다.

이러한 목적을 달성하기 위해 프로세스 스케줄러는 CPU에서의 프로그램의 실행을을 위해 사용가능한 프로세스를 선택하며, 어떤 프로세스를 프로세서에 할당할 것인가 결정하는 일을 프로세스 스케줄링이라고 한다.

<br/>

<br/>

## Scheduling Queues

 프로세스가 시스템에 들어오면 잡 큐(Job queue)에 들어간다.

잡 큐는 시스템의 모든 프로세스로 구성되어있다.

메인 메모리에서 실행을 기다리는 ready 상태의 프로세스들을 레디 큐(Ready queue)에 쌓인다.

입출력 장치를 기다리를 프로세스들은 디바이스 큐(Device queue)로 들어간다.

<br/>

<br/>

## Schedulers

레디 큐에 프로세스를 옮기는 것은 잡 스케줄러, 또는 Long-term 스케줄러라고 한다.

프로세스를 프로세서에 할당하는 것은 CPU 스케줄러, 또는 Short-term 스케줄러라고 한다.

 Long-term 스케줄러는 CPU 밖에서 가끔 수행된다.

Short-term 스케줄러는 그 반대다.

<br/>

<br/>

<br/>

<br/>

<br/>

# Context Switch

프로세스가 실행되다가



------

*제가 올린 글에서 잘못된 부분이 있으면 제 메일로 연락주세요!*

*Reference :  **[https://parksb.github.io/article/7.html](https://parksb.github.io/article/7.html)**, Operation System Concept*



<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br /><span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">이승수</span>의 저작물인 이 저작물은(는) <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 4.0 국제 라이선스</a>에 따라 이용할 수 있습니다.

